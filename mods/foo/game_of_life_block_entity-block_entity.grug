start_pos: id = get_world_position_of_block_entity(me)
start_x: i32 = get_block_pos_x(start_pos)
start_y: i32 = get_block_pos_y(start_pos) - 1
start_z: i32 = get_block_pos_z(start_pos)

g_level: id = get_block_entity_level(me)

white_concrete: id = get_default_block_state(block(resource_location("white_concrete")))
flag: i32 = block_flag_update_all()

current: id = hash_set()
scanned: id = hash_set()
next: id = hash_set()

running: bool = true
ticks: i32 = 0

on_spawn() {
    helper_spawn_glider()
}

on_tick() {
    if not running {
        return
    }

    ticks = ticks + 1
    if ticks > 1000 {
        return
    }
    if ticks % 20 != 0 {
        return
    }

    helper_scan()
    helper_update_next()
    helper_remove_current_blocks()
    helper_place_next_blocks()
    hash_set_copy(next, current)
}

on_neighbor_changed(block_state: id, level: id, block_pos: id, block_in: id, from_block_pos: id, is_moving: bool) {
    print_string("neighbor changed")
    running = not running
    if running {
        helper_remove_current_blocks()
        hash_set_clear(current)
        helper_spawn_glider()
    }
}

# Spawns a Glider pattern of blocks:
#  @
#   @
# @@@
helper_spawn_glider() {
    helper_place_offset_block(0, -1)
    helper_place_offset_block(1, 0)
    helper_place_offset_block(1, 1)
    helper_place_offset_block(0, 1)
    helper_place_offset_block(-1, 1)
}

helper_place_offset_block(x: i32, z: i32) {
    pos: id = block_pos(start_x + x, start_y, start_z + z)
    place_block(white_concrete, pos, flag, g_level)
    hash_set_add(current, pos)
}

helper_scan() {
    print_string("start of helper_scan()")
    hash_set_clear(scanned)

    iter: id = iterator(current)
    while iterating(iter) {
        print_string("a")
        pos: id = iteration(iter)
        helper_add_scanned(pos)
    }
    print_string("end of helper_scan()")
}

helper_add_scanned(pos: id) {
    x: i32 = -1
    while x <= 1 {
        z: i32 = -1
        while z <= 1 {
            hash_set_add(scanned, helper_get_pos(pos, x, z))
            z = z + 1
        }
        x = x + 1
    }
}

helper_update_next() {
    print_string("start of helper_update_next()")
    hash_set_clear(next)

    iter: id = iterator(scanned)
    while iterating(iter) {
        print_string("a")
        pos: id = iteration(iter)

        count: i32 = helper_count_neighbors(pos)

        if count == 3 or (count == 2 and hash_set_has(current, pos)) {
            hash_set_add(next, pos)
        }
    }
    print_string("end of helper_update_next()")
}

helper_count_neighbors(pos: id) i32 {
    count: i32 = 0

    x: i32 = -1
    while x <= 1 {
        z: i32 = -1
        while z <= 1 {
            if not (x == 0 and z == 0) {
                if helper_has_neighbor(pos, x, z) {
                    count = count + 1
                }
            }
            z = z + 1
        }
        x = x + 1
    }

    return count
}

helper_has_neighbor(pos: id, x: i32, z: i32) bool {
    return hash_set_has(current, helper_get_pos(pos, x, z))
}

helper_remove_current_blocks() {
    print_string("start of helper_remove_current_blocks()")
    iter: id = iterator(current)
    while iterating(iter) {
        print_string("a")
        pos: id = iteration(iter)
        remove_block(pos, g_level)
    }
    print_string("end of helper_remove_current_blocks()")
}

helper_place_next_blocks() {
    print_string("start of helper_place_next_blocks()")
    iter: id = iterator(next)
    while iterating(iter) {
        print_string("a")
        pos: id = iteration(iter)
        print_string("b")
        place_block(white_concrete, pos, flag, g_level)
        print_string("c")
    }
    print_string("end of helper_place_next_blocks()")
}

helper_get_pos(pos: id, x: i32, z: i32) id {
    return block_pos(get_block_pos_x(pos) + x, start_y, get_block_pos_z(pos) + z)
}
